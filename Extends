1.继承
 * 1.提高代码复用性。
 * 2.让类与类之间产生了关系，有了这个关系，才有了多态的特性。

 * 注意：千万不要为了获取其他类的功能，简化代码而继承。
         必须是类与类之间有所属关系才可以继承，所属关系 is a。

 * Java语言中，只支持单继承，不支持多继承。优化C++部分。
 * 因为多继承容易带来安全隐患：当多个父类中定义了相同功能，当功能内容不同时，子类对象不知道运行哪一个。
 * 多继承可以用另一种体现形式完成表示，多实现。
 * 
 * Java支持多层继承。即继承体系。
 * 
 * 如何使用一个继承体系中的功能？
 * 想要使用体系，先查阅体系中父类的描述，因为父类中定义的是体系中的共性功能。
 * 通过了解共性功能，就可以知道体系的基本功能。
 * 那么这个体系已经可以基本使用了。
 * 
 * 那么在具体调用时，要创建最子类的对象。为什么？
 * 1.因为父类可能不能创建对象。
 * 2.创建子类对象可以使用更多的功能，包括基本的和特有的。
 * 简单来说：查阅父类功能，创建子类对象使用功能。
 * 
 * 聚集：has a
 * 聚合：
 * 组合：





2. 子父类出现后，类成员的特点：
 * 
 * 类中成员：
 * 1.变量:如果子类中出现非私有的同名成员变量时，
 * 子类要访问本类中的变量，用this。this代表本类对象的引用
 * 子类要访问父类中的变量，用super。super表示父类对象的引用
 * 
 * 2.函数
 * 当子类出现和父类一模一样的函数时，
 * 当子类对象调用该函数，会运行子类函数的内容。
 * 如同父类的函数被覆盖一样。
 * 
 * 这种情况是函数的另一个特性：重写（覆盖）
 * 
 * 当子类继承父类，沿袭了父类的功能到子类中，但是子类虽然具有该功能，
 * 但是功能的内容与父类不一致。这时，没有必要创建新功能，而是使用覆盖特殊，
 * 保留父类的功能定义，并重写功能内容。
 * 
 * 覆盖：1.子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖。否则编译失败
 *      2.静态只能覆盖静态。
 * 
 * WARNING：重载：只看同名函数的参数列表
 *         重写：子父类方法一模一样
 * 
 * 3.子父类中的构造函数
 * 在对子类对象进行初始化时，父类的构造函数也会运行。
 * 那是因为子类的构造函数默认第一行有一条隐式语句super();
 * super()：会访问父类中空参数的构造函数，而且子类中所有构造函数第一行都是super();
 * 
 * 为什么子类一定要访问父类中的构造函数。
 * 因为父类中的数据子类可以直接获取，所以子类在建立时，需要查看父类是如何对这些数据初始化的。
 * 所以子类在对象初始化时，要先访问一下父类中的构造函数。
 * 如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来制定。
 * 
 * 注意：super语句一定定义在子类构造函数的第一行
 * 
 * 子类的实例化过程
 * 
 * 结论：子类所有的构造函数，默认都会访问父类中空参数的构造函数，
 * 因为子类每一个构造函数内第一行都有一句隐式的super();
 * 当父类中没有空参数构造函数时，子类必须手动通过this或super语句形式来指定要访问父类中的构造函数。
 * 当然子类构造函数第一句也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问 父类中的构造函数。
 







3.final：最终，作为一个修饰符
 * 1.可以修饰类，函数，变量。
 * 2.被final修饰的类不可以被继承。为了避免被继承，被子类复写功能。
 * 3.被final修饰的方法不可以被复写
 * 4.被final修饰的变量是一个常量，只能赋值一次，既可以修饰成员变量，也可以修饰局部变量
 * 当在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这些值起个名字，方便于阅读。
 * 而这个值不需要改变，所以加上final修饰。作为常量：书写规范所有的字母都大写，如果由多个单词组成，单词间通过"_"连接
 * 5.内部类定义在类中的局部位置上时，只能访问该局部被final修饰的局部变量。






4.抽象类
 * 当多个类中出现相同功能，但是功能主体不同，
 * 这时可以进行向上抽取。这时，只抽取功能定义，而不抽取功能主体。
 * 
 * 抽象：看不懂
 * 抽象类特点：
 * 1.抽象方法一定在抽象类中。
 * 2.抽象方法和抽象类都必须被abstract关键字修饰
 * 3.抽象类不可以用new新建对象，因为调用抽象方法没有意义
 * 4.抽象类中的方法要被使用，必须由子类复写其所有的抽象方法后，建立子类对象调用。
 *  如果子类只覆盖了部分抽象方法，那么子类还是一个抽象类。
 *  
 *  抽象类和一般类没有太大不同。
 *  该如何描述事物就如何描述事物，只不过，该事物出现了一些看不懂的东西。 
 *  这些不确定的部分也是该事物的功能，需要明确出现，但是无法定义主体。
 *  通过抽象方法表示。
 *  
 *  抽象类比一般类多了个抽象函数。就是在类中可以定义抽象方法。
 *  抽象类不可以实例化。
 *  
 *  特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。
